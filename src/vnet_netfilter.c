#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <linux/udp.h>
#include <linux/icmp.h>
#include <linux/skbuff.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Student - Ndtgithub3333");
MODULE_DESCRIPTION("Netfilter Hook for Virtual Network Packet Capture - Kernel-Safe Version Fixed");
MODULE_VERSION("2.1");

#define PROC_FILENAME "vnet_capture"
#define MAX_CAPTURED_PACKETS 1000

/* C·∫•u tr√∫c l∆∞u th√¥ng tin packet ƒë√£ b·∫Øt - t·ªëi ∆∞u cho kernel space */
struct packet_info {
    unsigned long timestamp;        // Th·ªùi gian b·∫Øt packet (jiffies)
    __be32 src_ip;                 // Source IP address (network byte order)
    __be32 dst_ip;                 // Destination IP address (network byte order)
    __be16 src_port;               // Source port (network byte order)
    __be16 dst_port;               // Destination port (network byte order)
    __u8 protocol;                 // Protocol type (TCP=6, UDP=17, ICMP=1)
    __u16 length;                  // Packet length t·ª´ IP header
    char interface[IFNAMSIZ];      // T√™n interface b·∫Øt packet
    char direction[10];            // H∆∞·ªõng packet: "IN" ho·∫∑c "OUT"
    bool is_valid;                 // Flag ƒë√°nh d·∫•u packet h·ª£p l·ªá
};

/* Ring buffer structure ƒë·ªÉ qu·∫£n l√Ω memory hi·ªáu qu·∫£ - c·∫£i thi·ªán t·ª´ array tƒ©nh */
struct packet_ring_buffer {
    struct packet_info *packets;   // M·∫£ng ƒë·ªông ch·ª©a packet info
    int head;                      // V·ªã tr√≠ ƒë·∫ßu c·ªßa ring buffer (newest)
    int tail;                      // V·ªã tr√≠ cu·ªëi c·ªßa ring buffer (oldest)
    int size;                      // S·ªë l∆∞·ª£ng packets hi·ªán t·∫°i trong buffer
    int max_size;                  // K√≠ch th∆∞·ªõc t·ªëi ƒëa c·ªßa buffer
    spinlock_t lock;               // Spinlock ƒë·ªÉ ƒë·ªìng b·ªô h√≥a multi-threaded access
    bool initialized;              // Flag ƒë√°nh d·∫•u buffer ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o
};

/* Global ring buffer instance v√† statistics */
static struct packet_ring_buffer capture_buffer;
static int total_packets = 0;                    // T·ªïng s·ªë packets ƒë√£ capture t·ª´ khi load module
static struct proc_dir_entry *proc_entry;       // Proc filesystem entry

/* H√†m kh·ªüi t·∫°o ring buffer v·ªõi proper error handling */
static int init_packet_ring_buffer(struct packet_ring_buffer *buffer, int max_size)
{
    // Validate input parameters - ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa tham s·ªë ƒë·∫ßu v√†o
    if (!buffer || max_size <= 0) {
        printk(KERN_ERR "netfilter_capture: Invalid parameters for ring buffer initialization\n");
        return -EINVAL;
    }

    // C·∫•p ph√°t memory cho ring buffer - s·ª≠ d·ª•ng kzalloc ƒë·ªÉ zero-initialize
    buffer->packets = kzalloc(max_size * sizeof(struct packet_info), GFP_KERNEL);
    if (!buffer->packets) {
        printk(KERN_ERR "netfilter_capture: Failed to allocate memory for ring buffer (%zu bytes)\n",
               max_size * sizeof(struct packet_info));
        return -ENOMEM;
    }

    // Kh·ªüi t·∫°o c√°c gi√° tr·ªã ban ƒë·∫ßu c·ªßa ring buffer
    buffer->head = 0;
    buffer->tail = 0;
    buffer->size = 0;
    buffer->max_size = max_size;
    buffer->initialized = true;
    spin_lock_init(&buffer->lock);

    printk(KERN_INFO "netfilter_capture: ‚úÖ Ring buffer initialized successfully (size: %d packets, memory: %zu bytes)\n", 
           max_size, max_size * sizeof(struct packet_info));
    return 0;
}

/* H√†m cleanup ring buffer ƒë·ªÉ ngƒÉn ng·ª´a memory leak */
static void cleanup_packet_ring_buffer(struct packet_ring_buffer *buffer)
{
    unsigned long flags;

    // Ki·ªÉm tra buffer c√≥ h·ª£p l·ªá kh√¥ng
    if (!buffer || !buffer->initialized) {
        return;
    }

    // Acquire lock ƒë·ªÉ ƒë·∫£m b·∫£o thread safety khi cleanup
    spin_lock_irqsave(&buffer->lock, flags);
    
    // Gi·∫£i ph√≥ng allocated memory
    if (buffer->packets) {
        kfree(buffer->packets);
        buffer->packets = NULL;
    }

    // Reset t·∫•t c·∫£ c√°c gi√° tr·ªã v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
    buffer->head = 0;
    buffer->tail = 0;
    buffer->size = 0;
    buffer->initialized = false;
    
    spin_unlock_irqrestore(&buffer->lock, flags);

    printk(KERN_INFO "netfilter_capture: ‚úÖ Ring buffer cleaned up successfully\n");
}

/* H√†m th√™m packet v√†o ring buffer v·ªõi thread-safe implementation */
static int add_packet_to_buffer(struct packet_ring_buffer *buffer, const struct packet_info *pkt_info)
{
    unsigned long flags;
    int next_head;

    // Validate input parameters - ki·ªÉm tra t√≠nh h·ª£p l·ªá c·ªßa tham s·ªë
    if (!buffer || !buffer->initialized || !pkt_info || !pkt_info->is_valid) {
        return -EINVAL;
    }

    spin_lock_irqsave(&buffer->lock, flags);

    // T√≠nh to√°n v·ªã tr√≠ head ti·∫øp theo trong circular buffer
    next_head = (buffer->head + 1) % buffer->max_size;

    // N·∫øu buffer ƒë·∫ßy, implement circular behavior (overwrite oldest)
    if (buffer->size == buffer->max_size) {
        // Clear old packet data tr∆∞·ªõc khi ghi ƒë√® ƒë·ªÉ ƒë·∫£m b·∫£o data integrity
        memset(&buffer->packets[buffer->head], 0, sizeof(struct packet_info));
        buffer->tail = (buffer->tail + 1) % buffer->max_size;
    } else {
        buffer->size++;
    }

    // Copy packet info v√†o buffer position
    memcpy(&buffer->packets[buffer->head], pkt_info, sizeof(struct packet_info));
    buffer->head = next_head;

    spin_unlock_irqrestore(&buffer->lock, flags);

    return 0;
}

/* H√†m validate IP packet ƒë·ªÉ ƒë·∫£m b·∫£o packet integrity */
static bool is_valid_ip_packet(struct sk_buff *skb)
{
    struct iphdr *ip_header;

    // Ki·ªÉm tra SKB c√≥ h·ª£p l·ªá v√† ƒë·ªß l·ªõn cho IP header kh√¥ng
    if (!skb || skb->len < sizeof(struct iphdr)) {
        return false;
    }

    // Ki·ªÉm tra protocol c√≥ ph·∫£i IP kh√¥ng
    if (skb->protocol != htons(ETH_P_IP)) {
        return false;
    }

    // L·∫•y v√† validate IP header
    ip_header = ip_hdr(skb);
    if (!ip_header) {
        return false;
    }

    // Ki·ªÉm tra IP version (ph·∫£i l√† IPv4)
    if (ip_header->version != 4) {
        return false;
    }

    // Ki·ªÉm tra IP header length h·ª£p l·ªá (t·ªëi thi·ªÉu 5 words = 20 bytes)
    if (ip_header->ihl < 5) {
        return false;
    }

    // Ki·ªÉm tra total length kh√¥ng v∆∞·ª£t qu√° SKB length
    if (ntohs(ip_header->tot_len) > skb->len) {
        return false;
    }

    return true;
}

/* H√†m ph√¢n t√≠ch v√† l∆∞u th√¥ng tin packet v·ªõi comprehensive validation */
static void analyze_and_store_packet(struct sk_buff *skb, const char *interface, const char *direction)
{
    struct iphdr *ip_header;
    struct tcphdr *tcp_header;
    struct udphdr *udp_header;
    struct packet_info pkt_info;
    int result;
    
    // Validate t·∫•t c·∫£ input parameters
    if (!skb || !interface || !direction) {
        printk(KERN_WARNING "netfilter_capture: Invalid parameters in analyze_and_store_packet\n");
        return;
    }

    // Validate IP packet tr∆∞·ªõc khi x·ª≠ l√Ω
    if (!is_valid_ip_packet(skb)) {
        return; // B·ªè qua packets kh√¥ng h·ª£p l·ªá
    }
    
    // Initialize packet info structure v·ªõi zero
    memset(&pkt_info, 0, sizeof(pkt_info));
    
    ip_header = ip_hdr(skb);
    
    // L∆∞u th√¥ng tin c∆° b·∫£n t·ª´ IP header
    pkt_info.timestamp = jiffies;
    pkt_info.src_ip = ip_header->saddr;
    pkt_info.dst_ip = ip_header->daddr;
    pkt_info.protocol = ip_header->protocol;
    pkt_info.length = ntohs(ip_header->tot_len);
    pkt_info.is_valid = true;

    // Copy interface name m·ªôt c√°ch an to√†n
    strncpy(pkt_info.interface, interface, IFNAMSIZ - 1);
    pkt_info.interface[IFNAMSIZ - 1] = '\0';

    // Copy direction string m·ªôt c√°ch an to√†n
    strncpy(pkt_info.direction, direction, sizeof(pkt_info.direction) - 1);
    pkt_info.direction[sizeof(pkt_info.direction) - 1] = '\0';
    
    // Extract port information cho TCP/UDP v·ªõi validation
    pkt_info.src_port = 0;
    pkt_info.dst_port = 0;
    
    if (ip_header->protocol == IPPROTO_TCP) {
        // Ki·ªÉm tra c√≥ ƒë·ªß data cho TCP header kh√¥ng
        if (skb->len >= (ip_header->ihl * 4) + sizeof(struct tcphdr)) {
            tcp_header = tcp_hdr(skb);
            if (tcp_header) {
                pkt_info.src_port = ntohs(tcp_header->source);
                pkt_info.dst_port = ntohs(tcp_header->dest);
            }
        }
    } else if (ip_header->protocol == IPPROTO_UDP) {
        // Ki·ªÉm tra c√≥ ƒë·ªß data cho UDP header kh√¥ng
        if (skb->len >= (ip_header->ihl * 4) + sizeof(struct udphdr)) {
            udp_header = udp_hdr(skb);
            if (udp_header) {
                pkt_info.src_port = ntohs(udp_header->source);
                pkt_info.dst_port = ntohs(udp_header->dest);
            }
        }
    }
    
    // Th√™m packet v√†o ring buffer
    result = add_packet_to_buffer(&capture_buffer, &pkt_info);
    if (result == 0) {
        total_packets++;
        printk(KERN_INFO "netfilter_capture: üì¶ Captured packet %s on %s: %pI4:%d -> %pI4:%d (protocol: %d, len: %d)\n",
               direction, interface,
               &pkt_info.src_ip, pkt_info.src_port,
               &pkt_info.dst_ip, pkt_info.dst_port,
               pkt_info.protocol, pkt_info.length);
    } else {
        printk(KERN_WARNING "netfilter_capture: Failed to store packet (error: %d)\n", result);
    }
}

/* Hook function cho INPUT chain - capture incoming packets */
static unsigned int hook_func_in(void *priv,
                                struct sk_buff *skb,
                                const struct nf_hook_state *state)
{
    // Validate hook state v√† input interface
    if (!state || !state->in) {
        return NF_ACCEPT;
    }

    // Ch·ªâ capture packets t·ª´ virtual interfaces c·ªßa ch√∫ng ta
    if (strncmp(state->in->name, "vnet", 4) == 0) {
        analyze_and_store_packet(skb, state->in->name, "IN");
    }
    
    return NF_ACCEPT; /* Lu√¥n cho ph√©p packet ƒëi ti·∫øp */
}

/* Hook function cho OUTPUT chain - capture outgoing packets */
static unsigned int hook_func_out(void *priv,
                                 struct sk_buff *skb,
                                 const struct nf_hook_state *state)
{
    // Validate hook state v√† output interface
    if (!state || !state->out) {
        return NF_ACCEPT;
    }

    // Ch·ªâ capture packets t·ª´ virtual interfaces c·ªßa ch√∫ng ta
    if (strncmp(state->out->name, "vnet", 4) == 0) {
        analyze_and_store_packet(skb, state->out->name, "OUT");
    }
    
    return NF_ACCEPT; /* Lu√¥n cho ph√©p packet ƒëi ti·∫øp */
}

/* C·∫•u tr√∫c netfilter hooks cho INPUT v√† OUTPUT chains */
static struct nf_hook_ops netfilter_ops_in = {
    .hook = hook_func_in,
    .hooknum = NF_INET_LOCAL_IN,
    .pf = PF_INET,
    .priority = NF_IP_PRI_FIRST,
};

static struct nf_hook_ops netfilter_ops_out = {
    .hook = hook_func_out,
    .hooknum = NF_INET_LOCAL_OUT,
    .pf = PF_INET,
    .priority = NF_IP_PRI_FIRST,
};

/* H√†m t√≠nh percentage m√† kh√¥ng d√πng floating point - kernel-safe 
 * ƒê·ªïi t√™n tham s·ªë ƒë·ªÉ tr√°nh xung ƒë·ªôt v·ªõi kernel macro 'current' */
static int calculate_usage_percentage(int current_count, int total_count)
{
    // Ki·ªÉm tra division by zero
    if (total_count == 0) {
        return 0;
    }
    // S·ª≠ d·ª•ng integer arithmetic thay v√¨ floating point
    // (current_count * 100) / total_count cho k·∫øt qu·∫£ ph·∫ßn trƒÉm
    return (current_count * 100) / total_count;
}

/* H√†m hi·ªÉn th·ªã th√¥ng tin trong /proc v·ªõi improved formatting v√† kernel-safe operations */
static int proc_show(struct seq_file *m, void *v)
{
    int i, current_size;
    struct packet_info *pkt;
    unsigned long flags;
    char protocol_name[8];
    char src_ip_str[16], dst_ip_str[16];
    int usage_percentage;

    // Header v·ªõi Unicode symbols v√† th√¥ng tin t·ªïng quan
    seq_puts(m, "================== Virtual Network Packet Capture Statistics ==================\n");
    seq_printf(m, "üìä Total packets captured: %d\n", total_packets);
    
    spin_lock_irqsave(&capture_buffer.lock, flags);
    current_size = capture_buffer.size;
    
    // T√≠nh percentage s·ª≠ d·ª•ng integer arithmetic (kernel-safe)
    // ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ tr√°nh xung ƒë·ªôt v·ªõi kernel macro
    usage_percentage = calculate_usage_percentage(current_size, capture_buffer.max_size);
    
    seq_printf(m, "üíæ Current buffer usage: %d/%d packets (%d%%)\n", 
               current_size, capture_buffer.max_size, usage_percentage);
    
    if (current_size == 0) {
        spin_unlock_irqrestore(&capture_buffer.lock, flags);
        seq_puts(m, "\nüîç No packets captured yet. Waiting for network activity...\n");
        seq_puts(m, "üí° Try: ping -I vnet0 192.168.10.2 (if interfaces are configured)\n");
        seq_puts(m, "üí° Or: nc -s 192.168.10.1 192.168.10.2 12345\n");
        return 0;
    }
    
    seq_puts(m, "\n");
    // T·∫°o table header v·ªõi box drawing characters ƒë·ªÉ hi·ªÉn th·ªã ƒë·∫πp
    seq_puts(m, "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n");
    seq_puts(m, "‚îÇ Timestamp  ‚îÇ Dir ‚îÇ   Source IP     ‚îÇ SPort ‚îÇ     Dest IP     ‚îÇ DPort ‚îÇ Proto ‚îÇ Len  ‚îÇ   Iface   ‚îÇ\n");
    seq_puts(m, "‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n");

    // Hi·ªÉn th·ªã packets t·ª´ tail ƒë·∫øn head (oldest to newest) cho chronological order
    for (i = 0; i < current_size; i++) {
        int idx = (capture_buffer.tail + i) % capture_buffer.max_size;
        pkt = &capture_buffer.packets[idx];

        // Skip invalid packets ƒë·ªÉ ƒë·∫£m b·∫£o data integrity
        if (!pkt->is_valid) {
            continue;
        }

        // Convert protocol number th√†nh human-readable string
        switch (pkt->protocol) {
            case IPPROTO_TCP:
                strcpy(protocol_name, "TCP");
                break;
            case IPPROTO_UDP:
                strcpy(protocol_name, "UDP");
                break;
            case IPPROTO_ICMP:
                strcpy(protocol_name, "ICMP");
                break;
            default:
                snprintf(protocol_name, sizeof(protocol_name), "%u", pkt->protocol);
                break;
        }

        // Convert IP addresses t·ª´ network byte order sang readable format
        snprintf(src_ip_str, sizeof(src_ip_str), "%pI4", &pkt->src_ip);
        snprintf(dst_ip_str, sizeof(dst_ip_str), "%pI4", &pkt->dst_ip);

        // Format output v·ªõi perfect alignment cho table structure
        seq_printf(m,
            "‚îÇ %10lu ‚îÇ %-3s ‚îÇ %15s ‚îÇ %5u ‚îÇ %15s ‚îÇ %5u ‚îÇ %5s ‚îÇ %4u ‚îÇ %-9s ‚îÇ\n",
            pkt->timestamp,
            pkt->direction,
            src_ip_str,
            pkt->src_port,
            dst_ip_str,
            pkt->dst_port,
            protocol_name,
            pkt->length,
            pkt->interface
        );
    }

    spin_unlock_irqrestore(&capture_buffer.lock, flags);

    // Table footer
    seq_puts(m, "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    
    // Helpful tips cho user
    seq_puts(m, "\nüí° Tips:\n");
    seq_puts(m, "   - Use 'dmesg | grep netfilter_capture' ƒë·ªÉ xem detailed logs\n");
    seq_puts(m, "   - Timestamps are in jiffies (kernel time ticks)\n");
    seq_puts(m, "   - Buffer size: ");
    seq_printf(m, "%d packets (circular buffer)\n", capture_buffer.max_size);
    seq_puts(m, "   - To convert jiffies to seconds: jiffies / HZ\n");
    seq_puts(m, "   - Current HZ value: ");
    seq_printf(m, "%d\n", HZ);

    return 0;
}

/* H√†m m·ªü proc file */
static int proc_open(struct inode *inode, struct file *file)
{
    return single_open(file, proc_show, NULL);
}

/* Proc file operations structure cho kernel interface */
static const struct proc_ops proc_fops = {
    .proc_open = proc_open,
    .proc_read = seq_read,
    .proc_lseek = seq_lseek,
    .proc_release = single_release,
};

/* H√†m kh·ªüi t·∫°o module v·ªõi comprehensive error handling */
static int __init vnet_netfilter_init(void)
{
    int ret;
    
    printk(KERN_INFO "netfilter_capture: üöÄ Starting Netfilter Hook initialization v2.1\n");
    
    // Kh·ªüi t·∫°o ring buffer tr∆∞·ªõc khi ƒëƒÉng k√Ω hooks
    ret = init_packet_ring_buffer(&capture_buffer, MAX_CAPTURED_PACKETS);
    if (ret) {
        printk(KERN_ERR "netfilter_capture: Failed to initialize ring buffer (error: %d)\n", ret);
        return ret;
    }
    
    // T·∫°o proc entry ƒë·ªÉ user space c√≥ th·ªÉ ƒë·ªçc statistics
    proc_entry = proc_create(PROC_FILENAME, 0444, NULL, &proc_fops);
    if (!proc_entry) {
        printk(KERN_ERR "netfilter_capture: Failed to create proc entry /proc/%s\n", PROC_FILENAME);
        cleanup_packet_ring_buffer(&capture_buffer);
        return -ENOMEM;
    }
    
    // ƒêƒÉng k√Ω netfilter hook cho INPUT chain
    ret = nf_register_net_hook(&init_net, &netfilter_ops_in);
    if (ret) {
        printk(KERN_ERR "netfilter_capture: Failed to register INPUT hook (error: %d)\n", ret);
        proc_remove(proc_entry);
        cleanup_packet_ring_buffer(&capture_buffer);
        return ret;
    }
    
    // ƒêƒÉng k√Ω netfilter hook cho OUTPUT chain
    ret = nf_register_net_hook(&init_net, &netfilter_ops_out);
    if (ret) {
        printk(KERN_ERR "netfilter_capture: Failed to register OUTPUT hook (error: %d)\n", ret);
        nf_unregister_net_hook(&init_net, &netfilter_ops_in);
        proc_remove(proc_entry);
        cleanup_packet_ring_buffer(&capture_buffer);
        return ret;
    }
    
    // Success logging v·ªõi useful information
    printk(KERN_INFO "netfilter_capture: ‚úÖ Initialization successful\n");
    printk(KERN_INFO "netfilter_capture: üìä View statistics at /proc/%s\n", PROC_FILENAME);
    printk(KERN_INFO "netfilter_capture: üíæ Ring buffer size: %d packets\n", MAX_CAPTURED_PACKETS);
    printk(KERN_INFO "netfilter_capture: üéØ Monitoring virtual network interfaces (vnet*)\n");
    printk(KERN_INFO "netfilter_capture: ‚è∞ System HZ value: %d (for jiffies conversion)\n", HZ);
    
    return 0;
}

/* H√†m cleanup module v·ªõi thorough resource deallocation */
static void __exit vnet_netfilter_exit(void)
{
    printk(KERN_INFO "netfilter_capture: üßπ Starting cleanup process\n");
    
    // Unregister netfilter hooks tr∆∞·ªõc ƒë·ªÉ stop capturing
    nf_unregister_net_hook(&init_net, &netfilter_ops_in);
    nf_unregister_net_hook(&init_net, &netfilter_ops_out);
    printk(KERN_INFO "netfilter_capture: ‚úÖ Netfilter hooks unregistered\n");
    
    // Remove proc entry ƒë·ªÉ ngƒÉn user space access
    proc_remove(proc_entry);
    printk(KERN_INFO "netfilter_capture: ‚úÖ Proc entry /proc/%s removed\n", PROC_FILENAME);
    
    // Cleanup ring buffer cu·ªëi c√πng ƒë·ªÉ gi·∫£i ph√≥ng memory
    cleanup_packet_ring_buffer(&capture_buffer);
    printk(KERN_INFO "netfilter_capture: ‚úÖ Ring buffer cleaned up\n");
    
    // Final statistics
    printk(KERN_INFO "netfilter_capture: üìä Total packets captured during session: %d\n", total_packets);
    printk(KERN_INFO "netfilter_capture: üéØ Cleanup completed successfully\n");
}

module_init(vnet_netfilter_init);
module_exit(vnet_netfilter_exit);